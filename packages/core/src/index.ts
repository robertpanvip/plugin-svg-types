import type { WatchListener } from "node:fs";
import fs from "node:fs";
import path from "node:path";

export type PluginSvgTypesOptions = {
  /**
   * 扫描 SVG 文件的输入目录路径。
   * The input directory path to scan for SVG files.
   * @default "src/assets/svg"
   */
  inputDir?: string;

  /**
   * 自动生成的类型声明文件的输出路径 (包含文件名)。
   * The output path for the auto-generated type declaration file (including filename).
   * @default "src/assets/svg/types.d.ts"
   */
  outputFile?: string;

  /**
   * 生成的 TypeScript 联合类型的名称。
   * The name of the generated TypeScript union type (e.g., 'IconName').
   * @default 'SvgIconName'
   */
  typeName?: string
};

type PluginApi = {
  onExit: (callback: () => void) => void
}

type Plugin = {
  name?: string;
  setup(api: PluginApi): void
}

export default function pluginSvgTypes(options: PluginSvgTypesOptions = {}): Plugin {
  const { inputDir = "src/assets/svg", outputFile = "src/assets/svg/types.d.ts", typeName = 'SvgIconName' } = options;

  function generate() {
    const absDir = path.resolve(inputDir);
    if (!fs.existsSync(absDir)) return;

    const files = fs
      .readdirSync(absDir)
      .filter((f) => f.endsWith(".svg"))
      .map((f) => path.basename(f, ".svg"));

    const union = files.map((f) => `"${f}"`).join(" | ") || "never";

    const content = `/**
 * WARNING: This file is auto-generated by plugin-svg-types.
 * Do not modify this file directly.
 * Generated at: ${new Date().toISOString()}
 */
export type ${typeName} = ${union};
export default ${typeName};
`;

    fs.writeFileSync(path.resolve(outputFile), content);
    console.log(`[pluginSvgTypes] 生成 icon types: ${files.length} 个`);
  }

  return {
    name: "svg-types-plugin",

    setup(api) {
      generate();
      let timer: NodeJS.Timeout | null = null;
      const listener: WatchListener<string> = (_, name) => {
        if (name?.endsWith(".svg")) {
          timer && clearTimeout(timer);
          timer = setTimeout(generate, 100);
        }
      };
      const watcher = fs.watch(inputDir, listener);
      api.onExit(() => {
        watcher.close();
        timer && clearTimeout(timer);
      });
    },
  };
}
